# 什么是 IO 复用

IO多路复用(multiplexing)的本质是通过一种机制(内核缓冲I/O数据), 让单个进程/线程可以监视多个文件描述符. 一旦某个描述符就绪(可读或可写), 通知应用程序进行相应的读写操作.   
比如某个socket可读的时候, 内核告知用户, 用户执行read操作, 这样就可以保证每次read都能读到有效数据, 再配合非阻塞socket使用, 单个进程就可以同时监视多个socket的读事件, 多个socket的IO操作都能在一个线程内交替地顺序完成, 这就叫IO多路复用, 这里的复用指的是复用同一个线程.  

socket()函数创建的套接字默认都是阻塞的, 当线程执行socket相关的API时, 调用不能立即完成, 线程一直处于等待状态直到操作完成获得结果或者超时. 如果线程阻塞于某一个socket的读写时, 将无法处理其它socket的请求, 这无疑是十分低效的. 当然可以采用多线程, 但大量的线程占用很大的内存空间, 并且线程切换会带来很大的开销. 而IO多路复用模型的优点就是单个线程能支持更多的并发连接请求.  
会引起阻塞的socket API分为以下四种:

* 外出连接: connect(). 对于TCP连接, 客户端以阻塞套接字为参数, 调用该函数向服务器发起连接. 该函数在收到服务器的应答前, 不会返回.这意味着TCP连接总会等待至少服务器的一次往返时间.
* 接受连接: accept(). 服务端以阻塞套接字为参数调用该函数, 等待客户端的连接请求, 如果此时没有连接请求. 线程就会进入睡眠状态.
* 读操作: read()、recv()、recvfrom(). 以阻塞套接字为参数调用该函数接收数据时, 如果套接字缓冲区内没有数据可读, 则调用线程在数据到来前一直睡眠.
* 写操作: write()、send()、sendto(). 以阻塞套接字为参数调用该函数发送数据时, 如果套接字缓冲区没有可用空间, 线程会一直睡眠直到有空间可写.

参考:  
[https://zhuanlan.zhihu.com/p/22834126](https://zhuanlan.zhihu.com/p/22834126)  
[https://www.zhihu.com/question/28594409](https://www.zhihu.com/question/28594409)  
[https://www.zhihu.com/question/32163005](https://www.zhihu.com/question/32163005)

## IO 模型

### 阻塞式IO(blocking IO)
如上所述, 默认情况所有的socket都是阻塞的, 以数据包套接字 recvfrom() 为例, 过程如下:

![](http://i.imgur.com/6oRQvoY.gif) 

应用程序调用 recvfrom(), 如果没有数据收到则线程或者进程就会被挂起, 直到数据到达并且被复制到应用进程的缓冲区或者发生错误才返回(最常见的错误是被信号中断). 进程从调用recvfrom()开始到它返回的整段时间内是被阻塞的.

### 非阻塞IO(non-blocking IO)
将IO设为非阻塞, 当执行read时如果没有数据, 则返回错误, 如EWOULDBLOCK. 这样就不会阻塞线程, 但是需要不断的轮询来读取或写入. 过程如下:

![](http://i.imgur.com/WqfQjTs.gif)



### IO 复用
Linux 下IO复用的实现主要有select, poll和epoll. 有了IO复用, 线程阻塞在这些系统调用之上, 而不是阻塞在具体的IO上.
